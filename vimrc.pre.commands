" search in dictionary
function! s:Dict(command)
  if ! executable('dict')
    echo "dict binary not found"
  else
    let command = join(map(split('dict ' . a:command), 'expand(v:val)'))
    let winnr = bufwinnr('^dict$')
    silent! execute  winnr < 0 ? 'botright new ' . fnameescape('dict') : winnr . 'wincmd w'
    setlocal buftype=nowrite bufhidden=wipe nobuflisted noswapfile nowrap
    echo 'Searching for word ' . command . '...'
    silent! execute 'silent %!'. command
    silent! execute 'resize ' . line('$')
    silent! redraw
    silent! execute 'au BufUnload <buffer> execute bufwinnr(' . bufnr('#') . ') . ''wincmd w'''
    silent! execute 'nnoremap <silent> <buffer> q :bd<CR>'
  endif
endfunction
command! -nargs=+ Dict call s:Dict(<q-args>)

" strip trailing whitespace
function! s:Strip()
  execute "normal mz"
  %s/\s\+$//gn
  %s/\s\+$//e
  execute "normal `z"
endfunction
command! Strip call s:Strip()

" open scratch buffer
function! s:Scratch()
  silent! execute ':enew'
  setlocal buftype=nofile bufhidden=hide noswapfile buflisted modifiable
endfunction
command! -nargs=? Scratch call s:Scratch()

" http://vimcasts.org/episodes/project-wide-find-and-replace/
function! s:QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction

command! -nargs=0 -bar Qargs execute 'args ' . s:QuickfixFilenames()
command! -nargs=1 -complete=command -bang Qdo exec 'bufdo bd' | exe 'args ' . s:QuickfixFilenames() | argdo<bang> <args>

function! s:SwitchSourceHeader()
  let source = ["cpp", "C", "c"]
  let header = ["h", "hpp"]
  let candidates = []

  for ext in source
    if expand("%:e") == ext
        let candidates = header
        break
    endif
  endfor

  for ext in header
    if expand("%:e") == ext
        let candidates = source
        break
    endif
  endfor

  for ext in candidates
    let file = expand("%:t:r") . "." . ext
    let found = findfile (file)
    if filereadable(found)
        execute ":edit " . found
        break
    endif
  endfor
endfunction
command! SwitchSourceHeader call s:SwitchSourceHeader()

" change directory to current file
command! Cd :cd %:p:h | :echo 'changed directory to '.getcwd()

" run external command
command! -nargs=1 -complete=shellcmd Run | execute ':silent !'.<q-args> | execute ':redraw!'
