function! s:recent_list()
    return map(filter(copy(v:oldfiles), 'v:val !~ "^/tmp/"'), 'substitute(v:val, "^\\~", $HOME, "")')
    "return filter(map(copy(v:oldfiles), 'expand(v:val)'), 'filereadable(v:val)')
endfunction

function! s:buf_list()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! s:buf_handler(e)
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

function! s:tag_handler(tag)
    if !empty(a:tag)
        let token = split(split(a:tag, '\t')[2],';"')[0]
        let m = &magic
        setlocal nomagic
        execute token
        if m
            setlocal magic
        endif
    endif
endfunction

function! s:yank_list()
    if exists(":Yanks")
        redir => ys
        silent Yanks
        redir END
        return split(ys, '\n')[1:]
    else
        return reverse(['0 ' . @0, '1 ' . @1, '2 ' . @2, '3 ' . @3, '4 ' . @4, '5 ' . @5, '6 ' . @6, '7 ' . @7, '8 ' . @8, '9 ' . @9])
    endif
endfunction

function! s:yank_handler(reg)
  if empty(a:reg)
    echo "aborted register paste"
  else
    let token = split(a:reg, ' ')
    if exists(":Yanks")
        execute 'Paste' . token[0]
    else
        execute 'normal! "' . token[0] . 'p'
    endif
  endif
endfunction

function! s:ag_prompt()
  call inputsave()
  let pattern = substitute(@/, '\\<', '', '')
  let pattern = substitute(pattern, '\\>', '', '')
  let pattern = input('Ag: ',pattern)
  call inputrestore()
  if empty(pattern)
    echo 'aborted search.'
  else
    let @/ = pattern
    execute 'Ag' pattern
  endif
endfunction

function! s:ag_curword()
  let pattern = expand('<cword>')
  if empty(pattern)
    echo "no word under cursor."
  else
    let pattern = '\b' . pattern . '\b'
    let @/ = pattern
    execute 'Ag' pattern
  endif
endfunction

function! s:ag_to_qf(line)
    let parts = split(a:line, ':')
    return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
            \ 'text': join(parts[3:], ':')}
endfunction

function! s:ag_handler(lines)
  if len(a:lines) < 2 | return | endif

  let cmd = get({'ctrl-x': 'split',
               \ 'ctrl-v': 'vertical split',
               \ 'ctrl-t': 'tabe'}, a:lines[0], 'e')
  let list = map(a:lines[1:], 's:ag_to_qf(v:val)')

  let first = list[0]
  execute cmd escape(first.filename, ' %#\')
  execute first.lnum
  execute 'normal!' first.col.'|zz'

  if len(list) > 1
    call setqflist(list)
    copen
    wincmd p
  endif
endfunction

function! s:dir_handler(dir)
  execute 'lcd ~/src/'.a:dir
  execute 'FZF' . '~/src/'.a:dir
  if has("nvim")
      call feedkeys('i')
  endif
endfunction

function! s:line_handler(l)
  let keys = split(a:l, ':\t')
  exec 'buf' keys[0]
  exec keys[1]
  normal! ^zz
endfunction

function! s:line_source()
  let res = []
  for b in filter(range(1, bufnr('$')), 'buflisted(v:val)')
    call extend(res, map(getbufline(b,0,"$"), 'b . ":\t" . (v:key + 1) . ":\t" . v:val '))
  endfor
  return res
endfunction

command! FZFLines call fzf#run({
\   'source':  <sid>line_source(),
\   'sink':    function('<sid>line_handler'),
\   'options': '--extended -d : --with-nth=3..',
\   'down':    '50%'
\})

command! -nargs=1 Ag call fzf#run({
\ 'source': 'ag --nogroup --column --color "'.escape(<q-args>, '"\').'"',
\ 'sink*': function('<sid>ag_handler'),
\ 'dir': getcwd(),
\ 'options': '--ansi --expect=ctrl-t,ctrl-v,ctrl-x '.
\            '--multi --bind ctrl-a:select-all,ctrl-d:deselect-all ',
\ 'down': '50%'
\ })

command! FZFTag if !empty(tagfiles()) | call fzf#run({
\ 'source': "sed '/^\\!/d;s/\t.*//' " . join(tagfiles()) . ' | uniq',
\ 'sink': 'tag',
\ 'options': '+m',
\ 'down': '50%'
\ }) | else | echo 'No tags' | endif

command! FZFTagFile if !empty(tagfiles()) | call fzf#run({
\ 'source': "cat " . join(tagfiles()) . ' | grep -P "' . expand('%:t') . '"',
\ 'sink': function('<sid>tag_handler'),
\ 'options': '+m --with-nth=1',
\ 'down': '50%'
\ }) | else | echo 'No tags' | endif

command! FZFBuf call fzf#run({
\ 'source': reverse(<sid>buf_list()),
\ 'sink': function('<sid>buf_handler'),
\ 'options': '-m',
\ 'down': len(<sid>buf_list()) + 2
\ })

command! FZFYank call fzf#run({
\ 'source': <sid>yank_list(),
\ 'sink': function('<sid>yank_handler'),
\ 'options': '-m',
\ 'down': 12
\ })

command! FZFRecent call fzf#run({
\ 'source': <sid>recent_list(),
\ 'sink': 'e',
\ 'options': '-m',
\ 'down': '50%'
\ })

command! FZFProjects call fzf#run({
\ 'source': "ls -1p ~/src | awk -F/ '/\\/$/ {print $1}'",
\ 'sink': function('<sid>dir_handler'),
\ 'options': '-m',
\ 'down': '50%'
\ })

nnoremap <silent> <Leader>t :FZFTagFile<CR>
nnoremap <silent> <Leader>T :FZFTag<CR>
nnoremap <silent> <Leader>f :FZF<CR>
nnoremap <silent> <Leader>a :call <sid>ag_prompt()<CR>
nnoremap <silent> <Leader>A :call <sid>ag_curword()<CR>
nnoremap <silent> <Leader>y :FZFYank<CR>
nnoremap <silent> <Leader>b :FZFBuf<CR>
nnoremap <silent> <Leader>r :FZFRecent<CR>
nnoremap <silent> <Leader>p :FZFProjects<CR>
nnoremap <silent> <Leader>j :FZFLines<CR>
